# -*- coding: utf-8 -*-
"""Untitled2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14ue33TF8metot6RzQivSOztoLUCp1NgK
"""

# Cell 1: Install required packages
!pip install fastapi uvicorn python-multipart
!pip install transformers torch torchvision pillow
!pip install requests numpy
!pip install pyngrok
!pip install python-jose[cryptography]

pip install pyngrok

# Cell 2: Import libraries and setup
import os
import io
import base64
import random
import requests
from PIL import Image
import torch
from transformers import BlipProcessor, BlipForConditionalGeneration
from fastapi import FastAPI, File, UploadFile, Form, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
import uvicorn
from pyngrok import ngrok
import asyncio
from typing import Optional

# Set up the device
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
print(f"Using device: {device}")

# Initialize FastAPI app
app = FastAPI(title="AI Caption Generator", description="Generate cool Instagram-style captions")

# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Cell 3: Load the pre-trained BLIP model
print("Loading BLIP model...")
processor = BlipProcessor.from_pretrained("Salesforce/blip-image-captioning-large")
model = BlipForConditionalGeneration.from_pretrained("Salesforce/blip-image-captioning-large").to(device)
print("Model loaded successfully!")

# Cell 4: Caption generation functions and prompts
class CaptionRequest(BaseModel):
    image_url: Optional[str] = None
    vibe: str = "happy"

def get_vibe_prompts(vibe: str):
    """Get creative prompts and emojis based on vibe"""
    vibe_data = {
        "happy": {
            "prompts": [
                "a joyful moment captured in time âœ¨",
                "pure happiness in one frame ðŸ˜Š",
                "when life gives you reasons to smile ðŸŒŸ",
                "radiating positive vibes only ðŸ’«",
                "happiness looks good on everything ðŸŒˆ"
            ],
            "emojis": ["ðŸ˜Š", "âœ¨", "ðŸŒŸ", "ðŸ’«", "ðŸŒˆ", "ðŸ˜", "ðŸ¥°", "ðŸ’•", "ðŸŽ‰", "ðŸŒ¸"]
        },
        "sad": {
            "prompts": [
                "sometimes the heart speaks through silence ðŸŒ§ï¸",
                "finding beauty in melancholy moments ðŸ’™",
                "when emotions paint the perfect picture ðŸŒ™",
                "embracing the bittersweet symphony of life ðŸƒ",
                "poetry written in shades of blue ðŸ’”"
            ],
            "emojis": ["ðŸŒ§ï¸", "ðŸ’™", "ðŸŒ™", "ðŸƒ", "ðŸ’”", "ðŸ˜¢", "ðŸŒŠ", "â›ˆï¸", "ðŸ¥€", "ðŸŒ«ï¸"]
        },
        "adventurous": {
            "prompts": [
                "adventure is calling and I must go ðŸ”ï¸",
                "collecting moments, not things ðŸŒ",
                "life is either a daring adventure or nothing at all âš¡",
                "wanderlust and wild hearts ðŸ—ºï¸",
                "chasing sunsets and new horizons ðŸŒ…"
            ],
            "emojis": ["ðŸ”ï¸", "ðŸŒ", "âš¡", "ðŸ—ºï¸", "ðŸŒ…", "ðŸ§—â€â™€ï¸", "ðŸš€", "ðŸŒ‹", "ðŸ•ï¸", "âœˆï¸"]
        },
        "romantic": {
            "prompts": [
                "love stories written in every detail ðŸ’•",
                "when hearts speak the same language ðŸ’–",
                "romance blooms in the simplest moments ðŸŒ¹",
                "love is in the air and everywhere ðŸ’˜",
                "creating fairytales one moment at a time âœ¨"
            ],
            "emojis": ["ðŸ’•", "ðŸ’–", "ðŸŒ¹", "ðŸ’˜", "âœ¨", "ðŸ’", "ðŸŒº", "ðŸ¦‹", "ðŸ’", "â¤ï¸"]
        },
        "mysterious": {
            "prompts": [
                "secrets hidden in plain sight ðŸŒ™",
                "mystery wrapped in enigma ðŸ”®",
                "where shadows dance and stories unfold ðŸŒš",
                "unraveling mysteries one frame at a time ðŸ—ï¸",
                "in the realm of the unknown ðŸŒŸ"
            ],
            "emojis": ["ðŸŒ™", "ðŸ”®", "ðŸŒš", "ðŸ—ï¸", "ðŸŒŸ", "ðŸŒ«ï¸", "ðŸ”", "ðŸ‘ï¸", "ðŸ¦‰", "âš¡"]
        },
        "energetic": {
            "prompts": [
                "energy that can't be contained âš¡",
                "pure adrenaline in motion ðŸ”¥",
                "when passion meets purpose ðŸ’¥",
                "unstoppable force meets immovable moment ðŸš€",
                "electric vibes only âš¡"
            ],
            "emojis": ["âš¡", "ðŸ”¥", "ðŸ’¥", "ðŸš€", "ðŸ’«", "â­", "ðŸŒŸ", "ðŸŽ¯", "ðŸƒâ€â™€ï¸", "ðŸ’ª"]
        }
    }
    return vibe_data.get(vibe, vibe_data["happy"])

def generate_cool_caption(base_caption: str, vibe: str):
    """Transform basic caption into Instagram-worthy caption"""
    vibe_info = get_vibe_prompts(vibe)
    prompt = random.choice(vibe_info["prompts"])
    emojis = random.sample(vibe_info["emojis"], min(3, len(vibe_info["emojis"])))

    # Caption templates for different styles
    templates = [
        f"{prompt}\n\n{' '.join(emojis)}",
        f"POV: {base_caption.lower()} {random.choice(emojis)}\n\n{prompt}",
        f"{base_caption} âœ¨\n\n{prompt}\n\n{' '.join(emojis)}",
        f"This. Right here. {random.choice(emojis)}\n\n{prompt}\n\n{' '.join(emojis)}",
        f"Plot twist: {base_caption.lower()} {random.choice(emojis)}\n\n{prompt}"
    ]

    return random.choice(templates)

def process_image(image):
    """Process image for caption generation"""
    if image.mode != 'RGB':
        image = image.convert('RGB')

    # Resize image if too large
    max_size = 512
    if max(image.size) > max_size:
        image.thumbnail((max_size, max_size), Image.Resampling.LANCZOS)

    return image

# Cell 5: API endpoints
@app.get("/")
async def root():
    return {"message": "AI Caption Generator API is running!"}

@app.post("/generate-caption-upload")
async def generate_caption_upload(
    file: UploadFile = File(...),
    vibe: str = Form("happy")
):
    """Generate caption from uploaded image file"""
    try:
        # Validate file type
        if not file.content_type.startswith('image/'):
            raise HTTPException(status_code=400, detail="File must be an image")

        # Read and process image
        contents = await file.read()
        image = Image.open(io.BytesIO(contents))
        image = process_image(image)

        # Generate base caption using BLIP
        inputs = processor(image, return_tensors="pt").to(device)
        with torch.no_grad():
            out = model.generate(**inputs, max_length=50, num_beams=5)
        base_caption = processor.decode(out[0], skip_special_tokens=True)

        # Transform to cool Instagram caption
        cool_caption = generate_cool_caption(base_caption, vibe.lower())

        return {
            "success": True,
            "caption": cool_caption,
            "base_caption": base_caption,
            "vibe": vibe
        }

    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error generating caption: {str(e)}")

@app.post("/generate-caption-url")
async def generate_caption_url(request: CaptionRequest):
    """Generate caption from image URL"""
    try:
        if not request.image_url:
            raise HTTPException(status_code=400, detail="Image URL is required")

        # Download image from URL
        response = requests.get(request.image_url, timeout=10)
        response.raise_for_status()

        image = Image.open(io.BytesIO(response.content))
        image = process_image(image)

        # Generate base caption using BLIP
        inputs = processor(image, return_tensors="pt").to(device)
        with torch.no_grad():
            out = model.generate(**inputs, max_length=50, num_beams=5)
        base_caption = processor.decode(out[0], skip_special_tokens=True)

        # Transform to cool Instagram caption
        cool_caption = generate_cool_caption(base_caption, request.vibe.lower())

        return {
            "success": True,
            "caption": cool_caption,
            "base_caption": base_caption,
            "vibe": request.vibe
        }

    except requests.RequestException:
        raise HTTPException(status_code=400, detail="Could not download image from URL")
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error generating caption: {str(e)}")

@app.get("/vibes")
async def get_available_vibes():
    """Get list of available vibes"""
    return {
        "vibes": ["happy", "sad", "adventurous", "romantic", "mysterious", "energetic"]
    }

import nest_asyncio
import uvicorn

ngrok.set_auth_token("31AlJuXfCHs6opLvtXrEfp45qgE_5ddxVm5BMpRntk5Qf7eVJ")
public_url = ngrok.connect(8000)
print(f"ðŸš€ Your API is now accessible at: {public_url}")
print(f"ðŸ“‹ Copy this URL for your frontend: {public_url}")

# Allow nested event loops
nest_asyncio.apply()

# Run server directly
uvicorn.run(app, host="0.0.0.0", port=8000)

