# -*- coding: utf-8 -*-
"""Untitled2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14ue33TF8metot6RzQivSOztoLUCp1NgK
"""

# Cell 1: Install required packages
!pip install fastapi uvicorn python-multipart
!pip install transformers torch torchvision pillow
!pip install requests numpy
!pip install pyngrok
!pip install python-jose[cryptography]

pip install pyngrok

# Cell 2: Import libraries and setup
import os
import io
import base64
import random
import requests
from PIL import Image
import torch
from transformers import BlipProcessor, BlipForConditionalGeneration
from fastapi import FastAPI, File, UploadFile, Form, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
import uvicorn
from pyngrok import ngrok
import asyncio
from typing import Optional

# Set up the device
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
print(f"Using device: {device}")

# Initialize FastAPI app
app = FastAPI(title="AI Caption Generator", description="Generate cool Instagram-style captions")

# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Cell 3: Load the pre-trained BLIP model
print("Loading BLIP model...")
processor = BlipProcessor.from_pretrained("Salesforce/blip-image-captioning-large")
model = BlipForConditionalGeneration.from_pretrained("Salesforce/blip-image-captioning-large").to(device)
print("Model loaded successfully!")

# Cell 4: Caption generation functions and prompts
class CaptionRequest(BaseModel):
    image_url: Optional[str] = None
    vibe: str = "happy"

def get_vibe_prompts(vibe: str):
    """Get creative prompts and emojis based on vibe"""
    vibe_data = {
        "happy": {
            "prompts": [
                "a joyful moment captured in time ✨",
                "pure happiness in one frame 😊",
                "when life gives you reasons to smile 🌟",
                "radiating positive vibes only 💫",
                "happiness looks good on everything 🌈"
            ],
            "emojis": ["😊", "✨", "🌟", "💫", "🌈", "😍", "🥰", "💕", "🎉", "🌸"]
        },
        "sad": {
            "prompts": [
                "sometimes the heart speaks through silence 🌧️",
                "finding beauty in melancholy moments 💙",
                "when emotions paint the perfect picture 🌙",
                "embracing the bittersweet symphony of life 🍃",
                "poetry written in shades of blue 💔"
            ],
            "emojis": ["🌧️", "💙", "🌙", "🍃", "💔", "😢", "🌊", "⛈️", "🥀", "🌫️"]
        },
        "adventurous": {
            "prompts": [
                "adventure is calling and I must go 🏔️",
                "collecting moments, not things 🌍",
                "life is either a daring adventure or nothing at all ⚡",
                "wanderlust and wild hearts 🗺️",
                "chasing sunsets and new horizons 🌅"
            ],
            "emojis": ["🏔️", "🌍", "⚡", "🗺️", "🌅", "🧗‍♀️", "🚀", "🌋", "🏕️", "✈️"]
        },
        "romantic": {
            "prompts": [
                "love stories written in every detail 💕",
                "when hearts speak the same language 💖",
                "romance blooms in the simplest moments 🌹",
                "love is in the air and everywhere 💘",
                "creating fairytales one moment at a time ✨"
            ],
            "emojis": ["💕", "💖", "🌹", "💘", "✨", "💝", "🌺", "🦋", "💐", "❤️"]
        },
        "mysterious": {
            "prompts": [
                "secrets hidden in plain sight 🌙",
                "mystery wrapped in enigma 🔮",
                "where shadows dance and stories unfold 🌚",
                "unraveling mysteries one frame at a time 🗝️",
                "in the realm of the unknown 🌟"
            ],
            "emojis": ["🌙", "🔮", "🌚", "🗝️", "🌟", "🌫️", "🔍", "👁️", "🦉", "⚡"]
        },
        "energetic": {
            "prompts": [
                "energy that can't be contained ⚡",
                "pure adrenaline in motion 🔥",
                "when passion meets purpose 💥",
                "unstoppable force meets immovable moment 🚀",
                "electric vibes only ⚡"
            ],
            "emojis": ["⚡", "🔥", "💥", "🚀", "💫", "⭐", "🌟", "🎯", "🏃‍♀️", "💪"]
        }
    }
    return vibe_data.get(vibe, vibe_data["happy"])

def generate_cool_caption(base_caption: str, vibe: str):
    """Transform basic caption into Instagram-worthy caption"""
    vibe_info = get_vibe_prompts(vibe)
    prompt = random.choice(vibe_info["prompts"])
    emojis = random.sample(vibe_info["emojis"], min(3, len(vibe_info["emojis"])))

    # Caption templates for different styles
    templates = [
        f"{prompt}\n\n{' '.join(emojis)}",
        f"POV: {base_caption.lower()} {random.choice(emojis)}\n\n{prompt}",
        f"{base_caption} ✨\n\n{prompt}\n\n{' '.join(emojis)}",
        f"This. Right here. {random.choice(emojis)}\n\n{prompt}\n\n{' '.join(emojis)}",
        f"Plot twist: {base_caption.lower()} {random.choice(emojis)}\n\n{prompt}"
    ]

    return random.choice(templates)

def process_image(image):
    """Process image for caption generation"""
    if image.mode != 'RGB':
        image = image.convert('RGB')

    # Resize image if too large
    max_size = 512
    if max(image.size) > max_size:
        image.thumbnail((max_size, max_size), Image.Resampling.LANCZOS)

    return image

# Cell 5: API endpoints
@app.get("/")
async def root():
    return {"message": "AI Caption Generator API is running!"}

@app.post("/generate-caption-upload")
async def generate_caption_upload(
    file: UploadFile = File(...),
    vibe: str = Form("happy")
):
    """Generate caption from uploaded image file"""
    try:
        # Validate file type
        if not file.content_type.startswith('image/'):
            raise HTTPException(status_code=400, detail="File must be an image")

        # Read and process image
        contents = await file.read()
        image = Image.open(io.BytesIO(contents))
        image = process_image(image)

        # Generate base caption using BLIP
        inputs = processor(image, return_tensors="pt").to(device)
        with torch.no_grad():
            out = model.generate(**inputs, max_length=50, num_beams=5)
        base_caption = processor.decode(out[0], skip_special_tokens=True)

        # Transform to cool Instagram caption
        cool_caption = generate_cool_caption(base_caption, vibe.lower())

        return {
            "success": True,
            "caption": cool_caption,
            "base_caption": base_caption,
            "vibe": vibe
        }

    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error generating caption: {str(e)}")

@app.post("/generate-caption-url")
async def generate_caption_url(request: CaptionRequest):
    """Generate caption from image URL"""
    try:
        if not request.image_url:
            raise HTTPException(status_code=400, detail="Image URL is required")

        # Download image from URL
        response = requests.get(request.image_url, timeout=10)
        response.raise_for_status()

        image = Image.open(io.BytesIO(response.content))
        image = process_image(image)

        # Generate base caption using BLIP
        inputs = processor(image, return_tensors="pt").to(device)
        with torch.no_grad():
            out = model.generate(**inputs, max_length=50, num_beams=5)
        base_caption = processor.decode(out[0], skip_special_tokens=True)

        # Transform to cool Instagram caption
        cool_caption = generate_cool_caption(base_caption, request.vibe.lower())

        return {
            "success": True,
            "caption": cool_caption,
            "base_caption": base_caption,
            "vibe": request.vibe
        }

    except requests.RequestException:
        raise HTTPException(status_code=400, detail="Could not download image from URL")
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error generating caption: {str(e)}")

@app.get("/vibes")
async def get_available_vibes():
    """Get list of available vibes"""
    return {
        "vibes": ["happy", "sad", "adventurous", "romantic", "mysterious", "energetic"]
    }

import nest_asyncio
import uvicorn

ngrok.set_auth_token("31AlJuXfCHs6opLvtXrEfp45qgE_5ddxVm5BMpRntk5Qf7eVJ")
public_url = ngrok.connect(8000)
print(f"🚀 Your API is now accessible at: {public_url}")
print(f"📋 Copy this URL for your frontend: {public_url}")

# Allow nested event loops
nest_asyncio.apply()

# Run server directly
uvicorn.run(app, host="0.0.0.0", port=8000)

